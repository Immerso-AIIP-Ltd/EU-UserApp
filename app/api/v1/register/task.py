import hashlib
import logging
import time
import uuid
from typing import Any, Dict

import bcrypt
import httpx
import oauthlib.oauth1
from celery import shared_task
from fastapi import Request

from app.core.constants import (
    DeviceNames,
    DeviceTypes,
    HeaderKeys,
    HeaderValues,
    HTTPMethods,
    LegacyLogMessages,
    LoginParams,
    PlatformTypes,
    RequestParams,
    UserAgentSubstrings,
)
from app.settings import settings

logger = logging.getLogger(__name__)


@shared_task(bind=True, name="block_ip_for_24_hours")
async def block_ip_for_24_hours(
    self: Any,
    ip_address: str,
    receiver: Any,
) -> None:
    """Blocks the given IP address for 24 hours using Redis."""
    # TODO: Refactor to use async redis or proper celery redis backend if needed.
    # Current implementation attempts to use broken 'utils.redis'.
    # disabling broken logic for now to allow app startup.
    logger.info(
        LegacyLogMessages.WOULD_BLOCK_IP.format(ip_address, receiver),
    )


async def get_hashed_password(plain_text_password: str) -> str:
    """Hash a plain text password using bcrypt."""
    password_bytes: bytes = plain_text_password.encode(LoginParams.UTF8)
    hashed: bytes = bcrypt.hashpw(password_bytes, bcrypt.gensalt())
    return hashed.decode(LoginParams.UTF8)


async def check_password(
    plain_text_password: str,
    hashed_password: str,
) -> bool:
    """Verify a plain text password against a bcrypt hash."""
    plain_bytes: bytes = plain_text_password.encode(LoginParams.UTF8)
    hashed_bytes: bytes = hashed_password.encode(LoginParams.UTF8)
    return bcrypt.checkpw(plain_bytes, hashed_bytes)


async def get_sha1_hash(plain_text_password: str) -> str:
    """Generate a SHA1 hash for legacy compatibility."""
    return hashlib.sha1(  # noqa: S324
        plain_text_password.encode(LoginParams.UTF8),
    ).hexdigest()


async def clone_object(obj: Any) -> Any:
    """Clone a database object by resetting its primary key."""
    obj.pk = None
    return obj


async def call_legacy_api(
    url_path: str,
    payload: dict[str, Any],
    consumer_key: str | None = None,
    consumer_secret: str | None = None,
) -> dict[str, Any]:
    """Call legacy API with OAuth1 signing."""
    if not consumer_key:
        consumer_key = settings.legacy_oauth_consumer_key
    if not consumer_secret:
        consumer_secret = settings.legacy_oauth_consumer_secret

    full_url = f"{settings.legacy_api_url}{url_path}"

    # Create OAuth1 client for signing
    client = oauthlib.oauth1.Client(
        client_key=consumer_key,
        client_secret=consumer_secret,
        signature_method=oauthlib.oauth1.SIGNATURE_HMAC_SHA1,
        timestamp=str(int(time.time())),
        nonce=str(uuid.uuid4()),
    )

    # Simplest valid usage if using oauthlib directly:
    # Note: sign() returns uri, headers, body. We use headers.
    uri, headers, body = client.sign(
        full_url,
        http_method=HTTPMethods.POST,
        body=payload,
        headers={HeaderKeys.CONTENT_TYPE: HeaderValues.APPLICATION_FORM_URLENCODED},
    )

    async with httpx.AsyncClient() as client:
        try:
            # We use the headers generated by oauthlib.
            # Note that 'body' returned by sign() is the encoded body, but
            # httpx .post(data=...) expects dict or bytes.
            # If body is string, we can pass it as content.
            response = await client.post(full_url, content=body, headers=headers)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logger.error(LegacyLogMessages.LEGACY_API_CALL_FAILED.format(e))
            raise e


async def get_device_info(request: Request) -> Dict[str, str]:  # noqa: C901, PLR0912
    """Infer device and platform information from request headers."""
    headers = request.headers
    ua = headers.get(HeaderKeys.USER_AGENT, "").lower()

    platform = headers.get(HeaderKeys.X_PLATFORM)
    if not platform:
        if UserAgentSubstrings.ANDROID in ua:
            platform = PlatformTypes.ANDROID
        elif UserAgentSubstrings.IPHONE in ua or UserAgentSubstrings.IPAD in ua:
            platform = PlatformTypes.IOS
        else:
            platform = PlatformTypes.WEB

    # Device type
    device_type = headers.get(HeaderKeys.X_DEVICE_TYPE)
    if not device_type:
        device_type = (
            DeviceTypes.MOBILE
            if platform in (PlatformTypes.ANDROID, PlatformTypes.IOS)
            else DeviceTypes.DESKTOP
        )

    # Device name
    device_name = headers.get(HeaderKeys.X_DEVICE_NAME)
    if not device_name:
        if platform == PlatformTypes.ANDROID:
            device_name = DeviceNames.ANDROID_DEVICE
        elif platform == PlatformTypes.IOS:
            device_name = DeviceNames.IPHONE
        else:
            if UserAgentSubstrings.WINDOWS in ua:
                device_name = DeviceNames.WINDOWS_BROWSER
            elif UserAgentSubstrings.MACINTOSH in ua:
                device_name = DeviceNames.MAC_BROWSER
            else:
                device_name = DeviceNames.WEB_BROWSER

            if UserAgentSubstrings.CHROME in ua:
                device_name += DeviceNames.CHROME
            elif UserAgentSubstrings.EDG in ua:
                device_name += DeviceNames.EDGE
            elif UserAgentSubstrings.FIREFOX in ua:
                device_name += DeviceNames.FIREFOX
    return {
        RequestParams.DEVICE_NAME: device_name,
        RequestParams.DEVICE_TYPE: device_type,
        RequestParams.PLATFORM: platform,
    }
