import hashlib
import logging
import time
import uuid
from typing import Any

import bcrypt
import httpx
import oauthlib.oauth1
from celery import shared_task
from fastapi import Request
from typing import Dict
from app.settings import settings

logger = logging.getLogger(__name__)

# from utils import redis # Removed broken import


@shared_task(bind=True, name="block_ip_for_24_hours")
async def block_ip_for_24_hours(
    self: Any,
    ip_address: str,
    receiver: Any,
) -> None:
    """
    Blocks the given IP address for 24 hours using Redis.
    """
    # TODO: Refactor to use async redis or proper celery redis backend if needed.
    # Current implementation attempts to use broken 'utils.redis'.
    # disabling broken logic for now to allow app startup.
    print(
        f"Would block IP address {ip_address}_{receiver} for 24 hours (Redis logic disabled).",
    )
    # BLOCK_DURATION_SECONDS = settings.BLOCK_DURATION_SECONDS
    # cache_key = f"blocked_ip_{ip_address}_{receiver}"
    # redis.set_val(cache_key, "1", timeout=BLOCK_DURATION_SECONDS)
    # print(f"Blocked IP address {ip_address}_{receiver} for 24 hours.")


async def get_hashed_password(plain_text_password: str) -> str:
    password_bytes: bytes = plain_text_password.encode("utf-8")
    hashed: bytes = bcrypt.hashpw(password_bytes, bcrypt.gensalt())
    return hashed.decode("utf-8")


async def check_password(
    plain_text_password: str,
    hashed_password: str,
) -> bool:
    plain_bytes: bytes = plain_text_password.encode("utf-8")
    hashed_bytes: bytes = hashed_password.encode("utf-8")
    return bcrypt.checkpw(plain_bytes, hashed_bytes)


async def get_sha1_hash(plain_text_password: str) -> str:
    return hashlib.sha1(
        plain_text_password.encode("utf-8"),
    ).hexdigest()


async def clone_object(obj: Any) -> Any:
    obj.pk = None
    return obj


async def call_legacy_api(
    url_path: str,
    payload: dict[str, Any],
    consumer_key: str | None = None,
    consumer_secret: str | None = None,
) -> dict[str, Any]:
    """
    Call legacy API with OAuth1 signing.
    """
    if not consumer_key:
        consumer_key = settings.legacy_oauth_consumer_key
    if not consumer_secret:
        consumer_secret = settings.legacy_oauth_consumer_secret

    full_url = f"{settings.legacy_api_url}{url_path}"

    # Create OAuth1 client for signing
    client = oauthlib.oauth1.Client(
        client_key=consumer_key,
        client_secret=consumer_secret,
        signature_method=oauthlib.oauth1.SIGNATURE_HMAC_SHA1,
        timestamp=str(int(time.time())),
        nonce=str(uuid.uuid4()),
    )

    # Simplest valid usage if using oauthlib directly:
    # Note: sign() returns uri, headers, body. We use headers.
    uri, headers, body = client.sign(
        full_url,
        http_method="POST",
        body=payload,
        headers={"Content-Type": "application/x-www-form-urlencoded"},
    )

    async with httpx.AsyncClient() as client:
        try:
            # We use the headers generated by oauthlib.
            # Note that 'body' returned by sign() is the encoded body, but httpx .post(data=...) expects dict or bytes.
            # If body is string, we can pass it as content.
            response = await client.post(full_url, content=body, headers=headers)
            response.raise_for_status()
            return response.json()
        except Exception as e:
            logger.error(f"Legacy API call failed: {e}")
            raise e


async def get_device_info(request: Request) -> Dict[str, str]:
    headers = request.headers
    ua = headers.get("user-agent", "").lower()

    # Platform (header > inference)
    platform = headers.get("x-platform")
    if not platform:
        if "android" in ua:
            platform = "android"
        elif "iphone" in ua or "ipad" in ua:
            platform = "ios"
        else:
            platform = "web"

    # Device type
    device_type = headers.get("x-device-type")
    if not device_type:
        device_type = "mobile" if platform in ("android", "ios") else "desktop"

    # Device name
    device_name = headers.get("x-device-name")
    if not device_name:
        if platform == "android":
            device_name = "Android Device"
        elif platform == "ios":
            device_name = "iPhone"
        else:
            if "windows" in ua:
                device_name = "Windows Browser"
            elif "macintosh" in ua:
                device_name = "Mac Browser"
            else:
                device_name = "Web Browser"

            if "chrome" in ua:
                device_name += " Chrome"
            elif "edg" in ua:
                device_name += " Edge"
            elif "firefox" in ua:
                device_name += " Firefox"
    return {
        "device_name": device_name,
        "device_type": device_type,
        "platform": platform,
    }
